# 처리기 모듈 작성 방법

## Docker의 도입

프레임워크에서 사용되는 처리기 모듈은 다양한 프로그래밍 언어로 작성될 수 있습니다.  
예를 들면 C, C++, Python, TypeScript 같은 언어가 이에 해당합니다.

이때 각각의 모듈은 서로 다른 버전의 언어 혹은 라이브러리를 요구할 수 있습니다. (e.g., Python 3.4와 Python3.8, OpenGL 4.2와 4.6)  
문제는 이러한 다른 요구사항을 가진 여러 모듈이 하나의 서버에서 실행될 수 있고, 또 서버가 필요에 따라 증가되거나 감소될 수 있기에 매번 언어와 라이브러리를 설치하는 것은 매우 부담스러운 일이라는 점입니다.

이러한 문제는 해결하기 위해 산업계에서는 이전부터 `Docker(도커)`라는 기술을 적극적으로 이용 중입니다.  
Docker는 경량화된 가상 OS라고 이해하면 쉽습니다.  
Docker에 대한 개념을 더 자세히 알고 싶으시면 [초보를 위한 도커 안내서 - 도커란 무엇인가?](https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html) 글을 읽어보시길 추천 드립니다.

우리 프레임워크에서는 처리기를 포함한 모든 모듈이 Docker 위에서 동작합니다.  
Python으로 작성된 모듈은 (a)와 같은 스크립트 대신 (b)와 같은 스크립트로 실행됩니다.

```bash
# (a)
$ python delta-renderer.py -i input.obj -o output.jpg

# (b)
$ docker run kaistgclab/delta-renderer -i input.obj -o output.jpg
```

이렇게 모든 모듈을 Docker에서 실행하면 일관성이 어느 정도 보장되고 모듈을 실행하는 코드가 짧아지게 됩니다.  
예를 들어, 모듈의 실행을 위해 필요한 각종 설치 과정 (언어의 버전부터 라이브러리의 설치까지) 모두 Docker 내부에 포함되게 되며, 프레임워크에서는 설치와 관련된 프로세스에 관여할 필요가 없습니다.

또한 일단 빌드가 성공하면, 어떤 곳(Ubuntu, CentOS, Windows, MacOS)에서 모듈을 실행시켜도 항상 같은 결과가 실행됨을 보장하기 때문에 동일한 환경 구축을 위해 수고를 하지 않아도 됩니다.


## 처리기 모듈의 통신 (파일 입출력)

처리기 모듈은 기본적으로 입력 파일을 받아 출력 파일을 내보내는 형태로 동작합니다.  
이때 Docker 컨테이너와 가장 쉽게 통신할 수 있는 방식은 `표준 입출력(Standard I/O)`을 이용하는 것입니다.  
하지만 3D 모델의 크기는 수백 KB~수백 MB에 이르며, 이 파일들을 표준 입출력을 통해 송수신하기에는 무리가 있습니다.

대신에 파라미터를 통해 입력 파일 이름과 출력 파일 이름을 지정하고 모듈을 실행하는 방법을 떠올릴 수 있습니다.  
하지만 Docker는 기본적으로 가상화된 환경입니다. Docker 컨테이너 내부에서는 기본적으로 외부(Host OS)의 파일에 접근할 수 없습니다.

Docker 컨테이너에게 파일을 전송하기 위해서, 또 Docker 컨테이너로부터 파일을 전송받기 위해서는 별도의 트릭이 필요합니다.  
우리 프레임워크에서는 그중 `Docker Volume`이라는 기능을 사용합니다.

### Docker Volume의 사용

Docker Volume은 Host의 특정 디렉토리를 Container의 특정 디렉토리로 매핑해주는 기능입니다.  
일반적으로 데이터베이스, 웹서버 등에서 생성하는 데이터 파일이나 로그 파일 등을 영구적으로 Host에 저장하기 위해 사용됩니다.

우리는 모듈과 통신을 위해, 매번 공유를 위한 전용 디렉토리를 생성하고 이를 Volume으로 매핑하는 방식을 이용합니다.
(모듈의 실행이 끝나면 해당 디렉토리는 필요에 따라 삭제할 수 있습니다.)  
아래는 Volume 설정과 함께 Docker 컨테이너를 실행하는 예시 코드입니다.

```bash
$ docker run \
    -v /tmp/execution-14231:/data \
    kaistgclab/delta-renderer \
    -i input.obj -o output.jpg
```

이 방식은 모듈 개발을 보다 편하게 만들어줍니다.  
Volume의 설정은 Docker를 실행하는 입장에서 설정해 주어야 하는 일이기에, 모듈 작성 시에는 이미 파일이 존재하다고 가정하고 코드를 기술할 수 있습니다.

## 처리기 모듈의 예시

해당 문서 작성 시점 2개의 모듈이 Docker를 통해 패키징되었습니다.

- 무효 처리기 계산 노드
    - https://github.com/kaist-gclab/delta-processor-null
    - TypeScript로 작성
- 미디얼 액시스 근사 계산 노드
    - https://github.com/kaist-gclab/delta-processor-axis
    - C++로 작성

위의 레파지토리에서 README 와 `Dockerfile`을 확인하시면 전체적으로 어떤 방식으로 모듈이 작성되는지를 파악하실 수 있습니다.

## 일광성 있는 처리기 모듈 개발

Docker Volume을 통한 모듈 통신 방법은 빠르고 편리하지만, 자유도가 매우 높기 때문에 일관성이 떨어질 수 있습니다.  
이를 위해 몇가지 규칙을 제안합니다. (규칙은 언제든지 수정될 수 있습니다!)

**1. 컨테이너의 `WORKDIR`은 `/data`를 사용합니다.**

모듈마다 다른 WORKDIR를 갖는 것은 코드의 복잡성을 증가시킬 수 있습니다.  
우리 프레임워크에서는 모듈을 실행할 때 컨테이너의 WORKDIR 및 데이터 위치를 `/data`로 고정하며, volume 매핑시에도 `/data`를 사용합니다.

**2. `/data` 디렉토리에는 입력 파일과 결과 파일들만 위치해야합니다.**

결과 파일이 여러 개인 경우에는 다수의 파일을 생성할 수 있습니다.  
단, 모듈의 entry point(e.g, `main.py`, `a.out`, `index.js`)가 `/data`에 위치되지 않도록 해주세요.

**3. input 파일 이름은 `-i` 옵션를 통해 전달합니다.**

입력파일은 항상 `-i` 옵션을 통해 전달할 수 있어야 합니다.

**4. 모듈 실행 결과는 `result.json`에 작성되며, 출력 파일의 위치 정보를 포함합니다.**

처리기 모듈마다 출력 파일의 이름과 확장자가 다를 수 있습니다.  
이에 따라서 별도 파일에 모듈의 실행 정보와 출력파일의 위치를 저장하도록 합니다.

예시:
```json
{
    "module_name": "delta-renderer",
    "result": "success",
    "input": "input.obj",
    "output": "output.jpg",
    "log": "log.log",
}
```
